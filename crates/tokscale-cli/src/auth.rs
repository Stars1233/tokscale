use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Credentials {
    pub token: String,
    pub username: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<String>,
    pub created_at: String,
}

#[derive(Debug, Deserialize)]
struct DeviceCodeResponse {
    #[serde(rename = "deviceCode")]
    device_code: String,
    #[serde(rename = "userCode")]
    user_code: String,
    #[serde(rename = "verificationUrl")]
    verification_url: String,
    #[serde(rename = "expiresIn")]
    #[allow(dead_code)]
    expires_in: u64,
    interval: u64,
}

#[derive(Debug, Deserialize)]
struct PollResponse {
    status: String,
    token: Option<String>,
    user: Option<UserInfo>,
    #[allow(dead_code)]
    error: Option<String>,
}

#[derive(Debug, Deserialize)]
struct UserInfo {
    username: String,
    #[serde(rename = "avatarUrl")]
    avatar_url: Option<String>,
}

fn get_credentials_path() -> PathBuf {
    let home = dirs::home_dir().expect("Could not determine home directory");
    home.join(".config/tokscale/credentials.json")
}

fn ensure_config_dir() -> Result<()> {
    let config_dir = dirs::home_dir()
        .expect("Could not determine home directory")
        .join(".config/tokscale");
    
    if !config_dir.exists() {
        fs::create_dir_all(&config_dir)?;
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            fs::set_permissions(&config_dir, fs::Permissions::from_mode(0o700))?;
        }
    }
    Ok(())
}

pub fn save_credentials(credentials: &Credentials) -> Result<()> {
    ensure_config_dir()?;
    let path = get_credentials_path();
    let json = serde_json::to_string_pretty(credentials)?;
    fs::write(&path, json)?;
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(&path, fs::Permissions::from_mode(0o600))?;
    }
    
    Ok(())
}

pub fn load_credentials() -> Option<Credentials> {
    let path = get_credentials_path();
    if !path.exists() {
        return None;
    }
    
    let content = fs::read_to_string(path).ok()?;
    serde_json::from_str(&content).ok()
}

pub fn clear_credentials() -> Result<bool> {
    let path = get_credentials_path();
    if path.exists() {
        fs::remove_file(path)?;
        Ok(true)
    } else {
        Ok(false)
    }
}

pub fn get_api_base_url() -> String {
    std::env::var("TOKSCALE_API_URL").unwrap_or_else(|_| "https://tokscale.ai".to_string())
}

fn get_device_name() -> String {
    let hostname = hostname::get()
        .ok()
        .and_then(|h| h.into_string().ok())
        .unwrap_or_else(|| "unknown".to_string());
    format!("CLI on {}", hostname)
}

fn open_browser(url: &str) {
    #[cfg(target_os = "macos")]
    {
        let _ = std::process::Command::new("open").arg(url).spawn();
    }
    
    #[cfg(target_os = "windows")]
    {
        let _ = std::process::Command::new("cmd")
            .args(["/C", "start", "", url])
            .spawn();
    }
    
    #[cfg(target_os = "linux")]
    {
        let _ = std::process::Command::new("xdg-open").arg(url).spawn();
    }
}

pub async fn login() -> Result<()> {
    use colored::Colorize;
    
    if let Some(creds) = load_credentials() {
        println!("\n  {}", format!("Already logged in as {}", creds.username.bold()).yellow());
        println!("{}", "  Run 'tokscale logout' to sign out first.\n".bright_black());
        return Ok(());
    }
    
    let base_url = get_api_base_url();
    
    println!("\n  {}\n", "Tokscale - Login".cyan());
    println!("{}", "  Requesting authorization code...".bright_black());
    
    let client = reqwest::Client::new();
    
    let device_code_response = client
        .post(format!("{}/api/auth/device", base_url))
        .json(&serde_json::json!({
            "deviceName": get_device_name()
        }))
        .send()
        .await?;
    
    if !device_code_response.status().is_success() {
        anyhow::bail!("Server returned {}", device_code_response.status());
    }
    
    let device_data: DeviceCodeResponse = device_code_response.json().await?;
    
    println!();
    println!("{}", "  Open this URL in your browser:".white());
    println!("{}", format!("  {}\n", device_data.verification_url).cyan());
    println!("{}", "  Enter this code:".white());
    println!("{}\n", format!("  {}", device_data.user_code).green().bold());
    
    open_browser(&device_data.verification_url);
    
    println!("{}", "  Waiting for authorization...".bright_black());
    
    let poll_interval = std::time::Duration::from_secs(device_data.interval);
    let max_attempts = 180;
    
    for attempt in 0..max_attempts {
        tokio::time::sleep(poll_interval).await;
        
        let poll_response = client
            .post(format!("{}/api/auth/device/poll", base_url))
            .json(&serde_json::json!({
                "deviceCode": device_data.device_code
            }))
            .send()
            .await;
        
        match poll_response {
            Ok(response) => {
                if let Ok(data) = response.json::<PollResponse>().await {
                    if data.status == "complete" {
                        if let (Some(token), Some(user)) = (data.token, data.user) {
                            let credentials = Credentials {
                                token,
                                username: user.username.clone(),
                                avatar_url: user.avatar_url,
                                created_at: chrono::Utc::now().to_rfc3339(),
                            };
                            
                            save_credentials(&credentials)?;
                            
                            println!("\n  {}", format!("Success! Logged in as {}", user.username.bold()).green());
                            println!("{}", "  You can now use 'tokscale submit' to share your usage.\n".bright_black());
                            return Ok(());
                        }
                    }
                    
                    if data.status == "expired" {
                        anyhow::bail!("Authorization code expired. Please try again.");
                    }
                    
                    print!("{}", ".".bright_black());
                    use std::io::Write;
                    std::io::stdout().flush()?;
                }
            }
            Err(_) => {
                print!("{}", "!".red());
                use std::io::Write;
                std::io::stdout().flush()?;
            }
        }
        
        if attempt >= max_attempts - 1 {
            anyhow::bail!("Timeout: Authorization took too long. Please try again.");
        }
    }
    
    Ok(())
}

pub fn logout() -> Result<()> {
    use colored::Colorize;
    
    let credentials = load_credentials();
    
    if credentials.is_none() {
        println!("\n  {}\n", "Not logged in.".yellow());
        return Ok(());
    }
    
    let username = credentials.unwrap().username;
    let cleared = clear_credentials()?;
    
    if cleared {
        println!("\n  {}\n", format!("Logged out from {}", username.bold()).green());
    } else {
        anyhow::bail!("Failed to clear credentials.");
    }
    
    Ok(())
}

pub fn whoami() -> Result<()> {
    use colored::Colorize;
    
    let credentials = load_credentials();
    
    if credentials.is_none() {
        println!("\n  {}", "Not logged in.".yellow());
        println!("{}", "  Run 'tokscale login' to authenticate.\n".bright_black());
        return Ok(());
    }
    
    let creds = credentials.unwrap();
    
    println!("\n  {}\n", "Tokscale - Account Info".cyan());
    println!("{}", format!("  Username:  {}", creds.username.bold()).white());
    
    if let Ok(created) = chrono::DateTime::parse_from_rfc3339(&creds.created_at) {
        println!("{}", format!("  Logged in: {}", created.format("%Y-%m-%d")).bright_black());
    }
    
    println!();
    
    Ok(())
}
